<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Disable panning and zooming on mobile */
        }
        canvas {
            background-color: #f7f1e3; /* Light cream background */
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .game-title {
            font-family: 'Press Start 2P', cursive;
        }
        .modal {
            transition: opacity 0.25s ease;
        }
        .theme-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .theme-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Theme Selection Screen -->
    <div id="theme-selection-screen" class="w-full max-w-3xl text-center">
        <h1 class="game-title text-3xl md:text-4xl text-amber-600 dark:text-amber-400 mb-8">Choose Your Adventure!</h1>
        <div class="grid grid-cols-2 md:grid-cols-3 gap-6">
            <div class="theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üê≠" data-exit="üßÄ">
                <span class="text-5xl">üê≠ ‚û°Ô∏è üßÄ</span>
                <p class="font-semibold mt-2">Mouse & Cheese</p>
            </div>
            <div class="theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="ü¶ñ" data-exit="üçñ">
                <span class="text-5xl">ü¶ñ ‚û°Ô∏è üçñ</span>
                <p class="font-semibold mt-2">Dinosaur & Meat</p>
            </div>
            <div class="theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üë©‚ÄçüöÄ" data-exit="üöÄ">
                <span class="text-5xl">üë©‚ÄçüöÄ ‚û°Ô∏è üöÄ</span>
                <p class="font-semibold mt-2">Astronaut & Rocket</p>
            </div>
            <div class="theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üêù" data-exit="üå∏">
                <span class="text-5xl">üêù ‚û°Ô∏è üå∏</span>
                <p class="font-semibold mt-2">Bee & Flower</p>
            </div>
            <div class="theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üöó" data-exit="üèÅ">
                <span class="text-5xl">üöó ‚û°Ô∏è üèÅ</span>
                <p class="font-semibold mt-2">Car & Finish Line</p>
            </div>
            <div class="theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üë®‚Äçüíª" data-exit="‚òïÔ∏è">
                <span class="text-5xl">üë®‚Äçüíª ‚û°Ô∏è ‚òïÔ∏è</span>
                <p class="font-semibold mt-2">Developer & Coffee</p>
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="w-full max-w-2xl text-center hidden">
        <h1 class="game-title text-3xl md:text-4xl text-amber-600 dark:text-amber-400">Maze Runner</h1>
        <p class="mt-2 text-lg">Use the arrow keys to find the goal!</p>
        
        <div class="relative my-6">
            <canvas id="mazeCanvas"></canvas>
            <!-- Win Message Modal -->
            <div id="winModal" class="absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center rounded-lg opacity-0 pointer-events-none modal">
                <div class="text-center text-white p-8">
                    <h2 class="game-title text-4xl text-yellow-400">Congratulations!</h2>
                    <p class="mt-4 text-xl">You found it!</p>
                </div>
            </div>
        </div>
        
        <div class="flex justify-center gap-4">
            <button id="newGameBtn" class="px-8 py-3 bg-amber-600 text-white font-bold rounded-lg shadow-md hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-amber-500 focus:ring-opacity-50 transition-transform transform hover:scale-105">
                New Game
            </button>
            <button id="changeThemeBtn" class="px-8 py-3 bg-gray-500 text-white font-bold rounded-lg shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 transition-transform transform hover:scale-105">
                Change Theme
            </button>
        </div>
    </div>

    <script>
        // DOM Elements
        const themeSelectionScreen = document.getElementById('theme-selection-screen');
        const gameScreen = document.getElementById('game-screen');
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const newGameBtn = document.getElementById('newGameBtn');
        const changeThemeBtn = document.getElementById('changeThemeBtn');
        const winModal = document.getElementById('winModal');

        // Game Configuration
        let maze, player, exit;
        let playerChar, exitChar;
        let cellSize;
        let cols, rows;
        let isGameOver = false;

        // Cell class for maze generation
        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.walls = { top: true, right: true, bottom: true, left: true };
                this.visited = false;
            }
            draw() {
                const x = this.x * cellSize;
                const y = this.y * cellSize;
                ctx.strokeStyle = '#4a4a4a';
                ctx.lineWidth = 3;
                if (this.walls.top) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + cellSize, y); ctx.stroke(); }
                if (this.walls.right) { ctx.beginPath(); ctx.moveTo(x + cellSize, y); ctx.lineTo(x + cellSize, y + cellSize); ctx.stroke(); }
                if (this.walls.bottom) { ctx.beginPath(); ctx.moveTo(x + cellSize, y + cellSize); ctx.lineTo(x, y + cellSize); ctx.stroke(); }
                if (this.walls.left) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + cellSize); ctx.stroke(); }
            }
        }

        // Sets up the canvas size based on the window
        function setupCanvas() {
            const containerWidth = Math.min(window.innerWidth * 0.9, 600);
            cellSize = Math.floor(containerWidth / 20); // Aim for a 20x20 grid
            cols = Math.floor(containerWidth / cellSize);
            rows = Math.floor(containerWidth / cellSize);
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;
        }

        // Starts a new game
        function newGame() {
            isGameOver = false;
            winModal.style.opacity = '0';
            winModal.style.pointerEvents = 'none';
            setupCanvas();
            maze = createGrid();
            generateMaze();
            
            player = { x: 0, y: 0 };
            exit = { x: cols - 1, y: rows - 1 };

            draw();
        }

        // Creates the initial grid of cells
        function createGrid() {
            const grid = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid.push(new Cell(x, y));
                }
            }
            return grid;
        }

        // Generates the maze using recursive backtracking
        function generateMaze() {
            const stack = [];
            let current = maze[0];
            current.visited = true;
            while (true) {
                const neighbors = getUnvisitedNeighbors(current);
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                    current.visited = true;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    break;
                }
            }
        }

        // Helper to get unvisited neighbors of a cell
        function getUnvisitedNeighbors(cell) {
            const neighbors = [];
            const { x, y } = cell;
            const top = maze[index(x, y - 1)];
            const right = maze[index(x + 1, y)];
            const bottom = maze[index(x, y + 1)];
            const left = maze[index(x - 1, y)];
            if (top && !top.visited) neighbors.push(top);
            if (right && !right.visited) neighbors.push(right);
            if (bottom && !bottom.visited) neighbors.push(bottom);
            if (left && !left.visited) neighbors.push(left);
            return neighbors;
        }

        // Helper to get the index in the 1D array from 2D coordinates
        function index(x, y) {
            if (x < 0 || y < 0 || x > cols - 1 || y > rows - 1) return -1;
            return x + y * cols;
        }

        // Removes walls between two adjacent cells
        function removeWalls(a, b) {
            const dx = a.x - b.x;
            if (dx === 1) { a.walls.left = false; b.walls.right = false; } 
            else if (dx === -1) { a.walls.right = false; b.walls.left = false; }
            const dy = a.y - b.y;
            if (dy === 1) { a.walls.top = false; b.walls.bottom = false; } 
            else if (dy === -1) { a.walls.bottom = false; b.walls.top = false; }
        }

        // Main draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            maze.forEach(cell => cell.draw());
            ctx.font = `${cellSize * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Use selected theme characters
            ctx.fillText(exitChar, exit.x * cellSize + cellSize / 2, exit.y * cellSize + cellSize / 2);
            ctx.fillText(playerChar, player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
        }

        // Handles player movement
        function movePlayer(e) {
            if (isGameOver) return;
            const currentCell = maze[index(player.x, player.y)];
            let moved = false;
            switch (e.key) {
                case 'ArrowUp': if (!currentCell.walls.top) { player.y--; moved = true; } break;
                case 'ArrowDown': if (!currentCell.walls.bottom) { player.y++; moved = true; } break;
                case 'ArrowLeft': if (!currentCell.walls.left) { player.x--; moved = true; } break;
                case 'ArrowRight': if (!currentCell.walls.right) { player.x++; moved = true; } break;
            }
            if (moved) {
                draw();
                checkWinCondition();
            }
        }

        // Checks if the player has reached the exit
        function checkWinCondition() {
            if (player.x === exit.x && player.y === exit.y) {
                isGameOver = true;
                winModal.style.opacity = '1';
                winModal.style.pointerEvents = 'auto';
            }
        }
        
        // --- Screen Management ---
        function showGameScreen() {
            themeSelectionScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
        }

        function showThemeScreen() {
            gameScreen.classList.add('hidden');
            themeSelectionScreen.classList.remove('hidden');
        }

        // Event Listeners
        themeSelectionScreen.addEventListener('click', (e) => {
            const themeCard = e.target.closest('.theme-card');
            if (!themeCard) return;

            playerChar = themeCard.dataset.player;
            exitChar = themeCard.dataset.exit;
            
            showGameScreen();
            newGame();
        });

        newGameBtn.addEventListener('click', newGame);
        changeThemeBtn.addEventListener('click', showThemeScreen);
        window.addEventListener('keydown', movePlayer);
        window.addEventListener('resize', () => {
             // Only resize if game is active
            if (!gameScreen.classList.contains('hidden')) {
                newGame();
            }
        });

    </script>

</body>
</html>
