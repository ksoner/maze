<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Educational Maze Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* touch-action is now handled dynamically via JavaScript */
        }
        canvas {
            background-color: #f7f1e3; /* Light cream background */
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .game-title {
            font-family: 'Press Start 2P', cursive;
        }
        .modal {
            transition: opacity 0.25s ease;
        }
        .card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }
        #word-display {
            font-family: 'Press Start 2P', cursive;
            letter-spacing: 0.5em;
            height: 40px; /* Reserve space */
            color: #8e44ad;
        }
        #message-box {
            transition: opacity 0.5s ease;
        }
        .d-pad-btn {
            width: 48px; /* Even smaller buttons */
            height: 48px;
            background-color: #cbd5e1;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            user-select: none; /* Prevent text selection on tap */
        }
        .d-pad-btn:active {
            background-color: #94a3b8;
            transform: translateY(2px);
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Difficulty Selection Screen -->
    <div id="difficulty-screen" class="w-full max-w-3xl text-center">
        <h1 class="game-title text-3xl md:text-4xl text-amber-600 dark:text-amber-400 mb-8">Choose a Difficulty</h1>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="card difficulty-card cursor-pointer bg-white dark:bg-gray-800 p-8 rounded-lg shadow-md" data-length="3">
                <p class="font-bold text-2xl">3-Letter Words</p>
            </div>
            <div class="card difficulty-card cursor-pointer bg-white dark:bg-gray-800 p-8 rounded-lg shadow-md" data-length="4">
                <p class="font-bold text-2xl">4-Letter Words</p>
            </div>
            <div class="card difficulty-card cursor-pointer bg-white dark:bg-gray-800 p-8 rounded-lg shadow-md" data-length="5">
                <p class="font-bold text-2xl">5-Letter Words</p>
            </div>
        </div>
    </div>

    <!-- Theme Selection Screen -->
    <div id="theme-selection-screen" class="w-full max-w-3xl text-center hidden">
        <h1 class="game-title text-3xl md:text-4xl text-amber-600 dark:text-amber-400 mb-2">Choose Your Adventure!</h1>
        <p class="mb-8 text-lg">Help your character collect letters to build a word!</p>
        <div class="grid grid-cols-2 md:grid-cols-3 gap-6">
            <div class="card theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üê≠" data-exit="üßÄ">
                <span class="text-5xl">üê≠ ... üßÄ</span>
                <p class="font-semibold mt-2">Mouse & Cheese</p>
            </div>
            <div class="card theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="ü¶ñ" data-exit="üçñ">
                <span class="text-5xl">ü¶ñ ... üçñ</span>
                <p class="font-semibold mt-2">Dinosaur & Meat</p>
            </div>
            <div class="card theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üë©‚ÄçüöÄ" data-exit="üöÄ">
                <span class="text-5xl">üë©‚ÄçüöÄ ... üöÄ</span>
                <p class="font-semibold mt-2">Astronaut & Rocket</p>
            </div>
            <div class="card theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üêù" data-exit="üå∏">
                <span class="text-5xl">üêù ... üå∏</span>
                <p class="font-semibold mt-2">Bee & Flower</p>
            </div>
            <div class="card theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üöó" data-exit="ÔøΩ">
                <span class="text-5xl">üöó ... üèÅ</span>
                <p class="font-semibold mt-2">Car & Finish Line</p>
            </div>
            <div class="card theme-card cursor-pointer bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md" data-player="üë®‚Äçüíª" data-exit="‚òïÔ∏è">
                <span class="text-5xl">üë®‚Äçüíª ... ‚òïÔ∏è</span>
                <p class="font-semibold mt-2">Developer & Coffee</p>
            </div>
        </div>
        <button id="backToDifficultyBtn" class="mt-8 px-6 py-2 bg-gray-500 text-white font-bold rounded-lg shadow-md hover:bg-gray-600">Back</button>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="w-full max-w-2xl text-center hidden">
        <h1 class="game-title text-2xl md:text-3xl text-amber-600 dark:text-amber-400">Collect the letters!</h1>
        <div id="word-display" class="my-2 text-3xl"></div>
        
        <div class="relative my-4">
            <canvas id="mazeCanvas"></canvas>
            <div id="winModal" class="absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center rounded-lg opacity-0 pointer-events-none modal">
                <div class="text-center text-white p-8 bg-purple-600 rounded-xl shadow-lg">
                    <h2 class="game-title text-3xl text-yellow-400">Well Done!</h2>
                    <p class="mt-4 text-2xl">You spelled:</p>
                    <p id="win-word" class="mt-2 text-5xl game-title text-white"></p>
                </div>
            </div>
        </div>
        
        <div id="message-box" class="h-8 mt-2 text-lg text-red-500 font-semibold"></div>

        <!-- On-screen D-pad controls for mobile -->
        <div id="d-pad-controls" class="mt-2 flex justify-center">
            <div class="grid grid-cols-3 grid-rows-3 w-36 h-36">
                <div class="col-start-2 row-start-1 flex justify-center items-center">
                    <button id="up-btn" class="d-pad-btn">
                        <svg class="w-8 h-8 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg>
                    </button>
                </div>
                <div class="col-start-1 row-start-2 flex justify-center items-center">
                    <button id="left-btn" class="d-pad-btn">
                        <svg class="w-8 h-8 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                    </button>
                </div>
                <div class="col-start-3 row-start-2 flex justify-center items-center">
                    <button id="right-btn" class="d-pad-btn">
                        <svg class="w-8 h-8 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </button>
                </div>
                <div class="col-start-2 row-start-3 flex justify-center items-center">
                    <button id="down-btn" class="d-pad-btn">
                        <svg class="w-8 h-8 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
            </div>
        </div>

        <div class="flex justify-center gap-4 mt-4">
            <button id="newGameBtn" class="px-8 py-3 bg-amber-600 text-white font-bold rounded-lg shadow-md hover:bg-amber-700">New Word</button>
            <button id="changeThemeBtn" class="px-8 py-3 bg-gray-500 text-white font-bold rounded-lg shadow-md hover:bg-gray-600">Change Theme</button>
        </div>
    </div>

    <script>
        // DOM Elements
        const difficultyScreen = document.getElementById('difficulty-screen');
        const themeSelectionScreen = document.getElementById('theme-selection-screen');
        const gameScreen = document.getElementById('game-screen');
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const newGameBtn = document.getElementById('newGameBtn');
        const changeThemeBtn = document.getElementById('changeThemeBtn');
        const backToDifficultyBtn = document.getElementById('backToDifficultyBtn');
        const winModal = document.getElementById('winModal');
        const wordDisplay = document.getElementById('word-display');
        const winWord = document.getElementById('win-word');
        const messageBox = document.getElementById('message-box');
        const upBtn = document.getElementById('up-btn');
        const downBtn = document.getElementById('down-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');

        // Game Configuration
        const wordsByLength = {
            3: ['cat', 'dog', 'sun', 'bed', 'pig', 'run', 'hat', 'pen', 'cup', 'egg', 'bus', 'car', 'key', 'jam', 'web', 'fox', 'zip'],
            4: ['frog', 'ship', 'fish', 'duck', 'hand', 'ball', 'star', 'moon', 'tree', 'book', 'milk', 'boat', 'flag'],
            5: ['train', 'plane', 'mouse', 'house', 'apple', 'water', 'table', 'chair', 'green', 'happy', 'smile', 'earth']
        };
        let chosenWordLength = 3;
        let targetWord = '';
        let letters = [];
        let nextLetterToCollectIndex = 0;
        
        let maze, player, exit;
        let playerChar, exitChar;
        let cellSize;
        let cols, rows;
        let isGameOver = false;
        let messageTimeout;

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.walls = { top: true, right: true, bottom: true, left: true };
                this.visited = false;
            }
            draw() {
                const x = this.x * cellSize;
                const y = this.y * cellSize;
                ctx.strokeStyle = '#4a4a4a';
                ctx.lineWidth = 3;
                if (this.walls.top) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + cellSize, y); ctx.stroke(); }
                if (this.walls.right) { ctx.beginPath(); ctx.moveTo(x + cellSize, y); ctx.lineTo(x + cellSize, y + cellSize); ctx.stroke(); }
                if (this.walls.bottom) { ctx.beginPath(); ctx.moveTo(x + cellSize, y + cellSize); ctx.lineTo(x, y + cellSize); ctx.stroke(); }
                if (this.walls.left) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + cellSize); ctx.stroke(); }
            }
        }

        function setupCanvas() {
            const containerWidth = Math.min(window.innerWidth * 0.9, 600);
            cellSize = Math.floor(containerWidth / 20);
            cols = Math.floor(containerWidth / cellSize);
            rows = Math.floor(containerWidth / cellSize);
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;
        }

        function newGame() {
            isGameOver = false;
            winModal.style.opacity = '0';
            winModal.style.pointerEvents = 'none';
            messageBox.textContent = '';
            
            const wordList = wordsByLength[chosenWordLength];
            targetWord = wordList[Math.floor(Math.random() * wordList.length)];
            letters = [];
            nextLetterToCollectIndex = 0;
            updateWordDisplay();

            setupCanvas();
            maze = createGrid();
            generateMaze();
            
            player = { x: 0, y: 0 };
            exit = { x: cols - 1, y: rows - 1 };
            
            const solutionPath = findSolutionPath();
            placeLetters(solutionPath);
            
            gameLoop();
        }
        
        function findSolutionPath() {
            const start = maze[index(0, 0)];
            const end = maze[index(cols - 1, rows - 1)];
            const queue = [[start]];
            const visited = new Set([start]);

            while (queue.length > 0) {
                const path = queue.shift();
                const current = path[path.length - 1];

                if (current === end) {
                    return path;
                }

                const { x, y } = current;
                const neighbors = [];
                if (!current.walls.top) neighbors.push(maze[index(x, y - 1)]);
                if (!current.walls.right) neighbors.push(maze[index(x + 1, y)]);
                if (!current.walls.bottom) neighbors.push(maze[index(x, y + 1)]);
                if (!current.walls.left) neighbors.push(maze[index(x - 1, y)]);
                
                for (const neighbor of neighbors) {
                    if (neighbor && !visited.has(neighbor)) {
                        visited.add(neighbor);
                        const newPath = [...path, neighbor];
                        queue.push(newPath);
                    }
                }
            }
            return [];
        }
        
        function placeLetters(solutionPath) {
            if (!solutionPath || solutionPath.length < 2) return;

            const numLetters = targetWord.length;
            const spacing = Math.floor(solutionPath.length / (numLetters + 1));

            for (let i = 0; i < numLetters; i++) {
                const pathIndex = (i + 1) * spacing;
                if (pathIndex < solutionPath.length) {
                    const cell = solutionPath[pathIndex];
                    letters.push({
                        char: targetWord[i],
                        x: cell.x,
                        y: cell.y,
                        collected: false
                    });
                }
            }
        }

        function updateWordDisplay() {
            let displayHTML = '';
            for (let i = 0; i < targetWord.length; i++) {
                if (i < nextLetterToCollectIndex) {
                    displayHTML += `<span>${targetWord[i]}</span>`;
                } else {
                    displayHTML += `<span>_</span>`;
                }
            }
            wordDisplay.innerHTML = displayHTML;
        }

        function createGrid() {
            const grid = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid.push(new Cell(x, y));
                }
            }
            return grid;
        }
        
        function generateMaze() {
            const stack = [];
            let current = maze[0];
            current.visited = true;
            while (true) {
                const neighbors = getUnvisitedNeighbors(current);
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                    current.visited = true;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    break;
                }
            }
        }
        
        function getUnvisitedNeighbors(cell) {
            const neighbors = [];
            const { x, y } = cell;
            const top = maze[index(x, y - 1)];
            const right = maze[index(x + 1, y)];
            const bottom = maze[index(x, y + 1)];
            const left = maze[index(x - 1, y)];
            if (top && !top.visited) neighbors.push(top);
            if (right && !right.visited) neighbors.push(right);
            if (bottom && !bottom.visited) neighbors.push(bottom);
            if (left && !left.visited) neighbors.push(left);
            return neighbors;
        }

        function index(x, y) {
            if (x < 0 || y < 0 || x > cols - 1 || y > rows - 1) return -1;
            return x + y * cols;
        }
        
        function removeWalls(a, b) {
            const dx = a.x - b.x;
            if (dx === 1) { a.walls.left = false; b.walls.right = false; } 
            else if (dx === -1) { a.walls.right = false; b.walls.left = false; }
            const dy = a.y - b.y;
            if (dy === 1) { a.walls.top = false; b.walls.bottom = false; } 
            else if (dy === -1) { a.walls.bottom = false; b.walls.top = false; }
        }

        function gameLoop() {
            draw();
            if (!isGameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            maze.forEach(cell => cell.draw());
            
            ctx.font = `${cellSize * 0.8}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            letters.forEach((letter, i) => {
                if (!letter.collected) {
                    ctx.fillStyle = i === nextLetterToCollectIndex ? '#8e44ad' : '#3498db';
                    const x = letter.x * cellSize + cellSize / 2;
                    const y = letter.y * cellSize + cellSize / 2;
                    if (i === nextLetterToCollectIndex) {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(Math.sin(Date.now() / 150) * 0.15);
                        ctx.fillText(letter.char, 0, 0);
                        ctx.restore();
                    } else {
                       ctx.fillText(letter.char, x, y);
                    }
                }
            });

            ctx.font = `${cellSize * 0.8}px Arial`;
            ctx.fillText(exitChar, exit.x * cellSize + cellSize / 2, exit.y * cellSize + cellSize / 2);
            ctx.fillText(playerChar, player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
        }

        function handleMove(direction) {
            if (isGameOver) return;
            const currentCell = maze[index(player.x, player.y)];
            let moved = false;
            switch (direction) {
                case 'up': if (!currentCell.walls.top) { player.y--; moved = true; } break;
                case 'down': if (!currentCell.walls.bottom) { player.y++; moved = true; } break;
                case 'left': if (!currentCell.walls.left) { player.x--; moved = true; } break;
                case 'right': if (!currentCell.walls.right) { player.x++; moved = true; } break;
            }
            if (moved) {
                checkLetterCollection();
                checkWinCondition();
            }
        }

        function handleKeyboard(e) {
            let direction = null;
            switch (e.key) {
                case 'ArrowUp': direction = 'up'; break;
                case 'ArrowDown': direction = 'down'; break;
                case 'ArrowLeft': direction = 'left'; break;
                case 'ArrowRight': direction = 'right'; break;
            }
            if(direction) {
                e.preventDefault(); // Prevent page scrolling with arrow keys
                handleMove(direction);
            }
        }

        function showTemporaryMessage(message) {
            clearTimeout(messageTimeout);
            messageBox.textContent = message;
            messageBox.style.opacity = '1';
            messageTimeout = setTimeout(() => {
                messageBox.style.opacity = '0';
            }, 2000);
        }

        function checkLetterCollection() {
            if (nextLetterToCollectIndex < letters.length) {
                const nextLetter = letters[nextLetterToCollectIndex];
                if (player.x === nextLetter.x && player.y === nextLetter.y) {
                    nextLetter.collected = true;
                    nextLetterToCollectIndex++;
                    updateWordDisplay();
                    return;
                }
            }
            for (let i = 0; i < letters.length; i++) {
                if (i === nextLetterToCollectIndex || letters[i].collected) continue;
                const wrongLetter = letters[i];
                if (player.x === wrongLetter.x && player.y === wrongLetter.y) {
                    showTemporaryMessage("Find the wiggling letter first!");
                    return;
                }
            }
        }

        function checkWinCondition() {
            if (player.x === exit.x && player.y === exit.y) {
                if (nextLetterToCollectIndex === targetWord.length) {
                    isGameOver = true;
                    winWord.textContent = targetWord;
                    winModal.style.opacity = '1';
                    winModal.style.pointerEvents = 'auto';
                } else {
                    showTemporaryMessage("Find all the letters first!");
                }
            }
        }
        
        // --- Screen Management ---
        function showDifficultyScreen() {
            difficultyScreen.classList.remove('hidden');
            themeSelectionScreen.classList.add('hidden');
            gameScreen.classList.add('hidden');
            document.body.style.touchAction = 'auto'; // Allow scrolling
        }

        function showThemeScreen() {
            difficultyScreen.classList.add('hidden');
            themeSelectionScreen.classList.remove('hidden');
            gameScreen.classList.add('hidden');
            document.body.style.touchAction = 'auto'; // Allow scrolling
        }

        function showGameScreen() {
            difficultyScreen.classList.add('hidden');
            themeSelectionScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            document.body.style.touchAction = 'none'; // Prevent scrolling ONLY on game screen
        }

        // --- Event Listeners ---
        difficultyScreen.addEventListener('click', (e) => {
            const difficultyCard = e.target.closest('.difficulty-card');
            if (!difficultyCard) return;
            chosenWordLength = parseInt(difficultyCard.dataset.length, 10);
            showThemeScreen();
        });

        themeSelectionScreen.addEventListener('click', (e) => {
            const themeCard = e.target.closest('.theme-card');
            if (!themeCard) return;
            playerChar = themeCard.dataset.player;
            exitChar = themeCard.dataset.exit;
            showGameScreen();
            newGame();
        });

        backToDifficultyBtn.addEventListener('click', showDifficultyScreen);
        newGameBtn.addEventListener('click', newGame);
        changeThemeBtn.addEventListener('click', showThemeScreen);
        window.addEventListener('keydown', handleKeyboard);
        window.addEventListener('resize', () => {
            if (!gameScreen.classList.contains('hidden')) {
                newGame();
            }
        });

        // D-pad controls
        upBtn.addEventListener('click', () => handleMove('up'));
        downBtn.addEventListener('click', () => handleMove('down'));
        leftBtn.addEventListener('click', () => handleMove('left'));
        rightBtn.addEventListener('click', () => handleMove('right'));

    </script>
</body>
</html>
ÔøΩ
